{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "dd9e7302",
   "metadata": {},
   "outputs": [],
   "source": [
    "from pathlib import Path\n",
    "from typing import Dict, Any, List, Optional\n",
    "import csv\n",
    "\n",
    "\n",
    "def count_words(text: str) -> Dict[str, int]:\n",
    "    \"\"\"\n",
    "    Функция для подсчета слов в тексте.\n",
    "\n",
    "    При подсчете слов - все знаки препинания игнорируются.\n",
    "    Словом считается непрерывная последовательность длиной больше одного\n",
    "    символа, состоящая из букв в диапазоне A-Z и a-z.\n",
    "    Если в последовательности присутствует цифра - это не слово.\n",
    "\n",
    "    Hello - слово\n",
    "    Hello7 - не слово\n",
    "\n",
    "    При подсчете слов регистр букв не имеет значения.\n",
    "\n",
    "    Результат выполнения функции словарь, в котором:\n",
    "    ключ - слово в нижнем регистре\n",
    "    значение - количество вхождений слов в текст\n",
    "\n",
    "    :param text: текст, для подсчета символов\n",
    "    :return: словарь, в котором:\n",
    "             ключ - слово в нижнем регистре\n",
    "             значение - количество вхождений слов в текст\n",
    "    \"\"\"\n",
    "\n",
    "    import re\n",
    "\n",
    "    word_counts = {}\n",
    "\n",
    "    words = re.findall(r'\\b[a-zA-Z]+\\b', text)\n",
    "    for word in words:\n",
    "        word = word.lower()\n",
    "        if word not in word_counts:\n",
    "            word_counts[word] = 1\n",
    "        else:\n",
    "            word_counts[word] += 1\n",
    "\n",
    "    return word_counts\n",
    "\n",
    "\n",
    "def exp_list(numbers: List[int], exp: int) -> List[int]:\n",
    "    \"\"\"\n",
    "    Функция, которая возводит каждый элемент списка в заданную степень\n",
    "\n",
    "    :param numbers: список, состоящий из натуральных чисел\n",
    "    :param exp: в какую степень возвести числа в списке\n",
    "    :return: список натуральных чисел\n",
    "    \"\"\"\n",
    "\n",
    "    powered_numbers = [number ** exp for number in numbers]\n",
    "    return powered_numbers\n",
    "\n",
    "\n",
    "def get_cashback(operations: List[Dict[str, Any]], special_category: List[str]) -> float:\n",
    "    \"\"\"\n",
    "    Функция для расчета кешбека по операциям.\n",
    "    За покупки в обычных категориях возвращается 1% от стоимости покупки\n",
    "    За покупки в special_category начисляют 5% от стоимости покупки\n",
    "\n",
    "    :param operations: список словарей, содержащих поля\n",
    "           amount - сумма операции\n",
    "           category - категория покупки\n",
    "    :param special_category: список категорий повышенного кешбека\n",
    "    :return: размер кешбека\n",
    "    \"\"\"\n",
    "\n",
    "    total_cashback = 0\n",
    "\n",
    "    for operation in operations:\n",
    "        amount = operation['amount']\n",
    "        category = operation['category']\n",
    "\n",
    "        if category in special_category:\n",
    "            cashback = amount * 0.05\n",
    "        else:\n",
    "            cashback = amount * 0.01\n",
    "\n",
    "        total_cashback += cashback\n",
    "\n",
    "    return total_cashback\n",
    "\n",
    "\n",
    "def get_path_to_file() -> Optional[Path]:\n",
    "    \"\"\"\n",
    "    Находит корректный путь до тестового файла.\n",
    "\n",
    "    Если запускать тесты из pycharm - начальная папка - tests\n",
    "    Если запускать файлы через make tests - начальная папка - корень проекта\n",
    "\n",
    "    :return: путь до тестового файла tasks.csv\n",
    "    \"\"\"\n",
    "    if Path().resolve().name == 'tests':\n",
    "        base_path = Path().resolve().parent\n",
    "    else:\n",
    "        base_path = Path().resolve()\n",
    "    return base_path / 'tasks' / 'practice3' / 'tasks.csv'\n",
    "\n",
    "\n",
    "def csv_reader(header: str) -> int:\n",
    "    \"\"\"\n",
    "    Функция считывает csv файл и подсчитывает количество\n",
    "    уникальных элементов в столбце.\n",
    "    Столбец выбирается на основе имени заголовка,\n",
    "    переданного в переменной header.\n",
    "\n",
    "    Обратите внимание на структуру файла!\n",
    "    Первая строка - строка с заголовками.\n",
    "    Остальные строки - строки с данными.\n",
    "\n",
    "    Файл для анализа: tasks.csv\n",
    "    Для того чтобы файл корректно открывался в тестах:\n",
    "    для получения пути до файла - используйте функцию get_path_to_file\n",
    "    которая определена перед функцией.\n",
    "\n",
    "    CSV анализируем с помощью встроенной библиотеки csv\n",
    "\n",
    "    :param header: название заголовка\n",
    "    :return: количество уникальных элементов в столбце\n",
    "    \"\"\"\n",
    "\n",
    "    file_path = get_path_to_file()\n",
    "    unique_values = set()\n",
    "\n",
    "    with open(file_path, 'r') as file:\n",
    "        csv_reader = csv.DictReader(file)\n",
    "        for row in csv_reader:\n",
    "            value = row[header]\n",
    "            unique_values.add(value)\n",
    "\n",
    "    return len(unique_values)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.9"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
